#ifndef __LHKEYBOARD_H__
#define __LHKEYBOARD_H__

#include <string.h>
#include "LHWindows.h"
extern CRITICAL_SECTION KeyboardControl;

void LHResetKeyboard();
/**********************************************
 typedefs
 *********************************************/


//*****************************************************************************
//	LH_KEY contains all the keycodes generated by extended keyboard.
//	InKey() holds these LH_KEY values and these are also the indexes into
//	the KeyDownArray[].
//*****************************************************************************

enum LH_KEY
{
	KB_NONE			= 0x000,
	KB_ESC			= 0x001,
	KB_ESCAPE		= 0x001,						// Duplicate
	KB_1			= 0x002,
	KB_2			= 0x003,
	KB_3			= 0x004,
	KB_4			= 0x005,
	KB_5			= 0x006,
	KB_6			= 0x007,
	KB_7			= 0x008,
	KB_8			= 0x009,
	KB_9			= 0x00a,
	KB_0			= 0x00b,
	KB_MINUS		= 0x00c,
	KB_EQUAL		= 0x00d,
	KB_BACKSPACE	= 0x00e,
	KB_TAB			= 0x00f,
	KB_Q			= 0x010,
	KB_W			= 0x011,
	KB_E			= 0x012,
	KB_R			= 0x013,
	KB_T			= 0x014,
	KB_Y			= 0x015,
	KB_U			= 0x016,
	KB_I			= 0x017,
	KB_O			= 0x018,
	KB_P			= 0x019,
	KB_LSBRACKET	= 0x01a,
	KB_RSBRACKET	= 0x01b,
	KB_RETURN		= 0x01c,
	KB_LCTRL		= 0x01d,

	KB_A			= 0x01e,
	KB_S			= 0x01f,
	KB_D			= 0x020,
	KB_F			= 0x021,
	KB_G			= 0x022,
	KB_H			= 0x023,
	KB_J			= 0x024,
	KB_K			= 0x025,
	KB_L			= 0x026,
	KB_COLON		= 0x027,
	KB_QUOTE		= 0x028,
	KB_QUOTE2		= 0x029,
	KB_LSHIFT		= 0x02a,
	KB_HASH			= 0x02b,
	KB_BACKSLASH	= 0x056,
	KB_Z			= 0x02c,
	KB_X			= 0x02d,
	KB_C			= 0x02e,
	KB_V			= 0x02f,
	KB_B			= 0x030,
	KB_N			= 0x031,
	KB_M			= 0x032,
	KB_COMMA		= 0x033,
	KB_DOT			= 0x034,
	KB_SLASH		= 0x035,
	KB_RSHIFT		= 0x036,

	KB_LALT			= 0x038,
	KB_SPACE		= 0x039,
	KB_CAPS			= 0x03a,
	KB_F1			= 0x03b,
	KB_F2			= 0x03c,
	KB_F3			= 0x03d,
	KB_F4			= 0x03e,
	KB_F5			= 0x03f,
	KB_F6			= 0x040,
	KB_F7			= 0x041,
	KB_F8			= 0x042,
	KB_F9			= 0x043,
	KB_F10			= 0x044,
	KB_F11			= 0x057,
	KB_F12			= 0x058,
	KB_SCROLL_LOCK	= 0x046,
	KB_NUM_LOCK		= 0x045,	
	KB_PMINUS		= 0x04a,		
	KB_PLUS			= 0x04e,
	KB_ASTERISK		= 0x037,	
	KB_PDOT			= 0x053,	
	
	// Extended Keys
	
	KB_RALT			= 0x038 + 0x80,
	KB_RCTRL		= 0x01d + 0x80,
	KB_PRINT_SCR	= 0x037 + 0x80,

	KB_HOME			= 0x047 + 0x80,
	KB_UP			= 0x048 + 0x80,
	KB_PGUP			= 0x049 + 0x80,
	KB_LEFT			= 0x04b + 0x80,
	KB_RIGHT		= 0x04d + 0x80,
	KB_END			= 0x04f + 0x80,
	KB_DOWN			= 0x050 + 0x80,
	KB_PGDN			= 0x051 + 0x80,
	KB_INSERT		= 0x052 + 0x80,
	KB_DELETE		= 0x053 + 0x80,
	KB_ENTER		= 0x01c + 0x80,

	// Windows Keys

	KB_LWIN			= 0xDB,
	KB_RWIN			= 0xDC,
	KB_WAPP			= 0xDD

};

enum	LH_SHIFT
{
	LH_NO_SHIFT		= 0,
	LH_SHIFT		= 128,
};

//*****************************************************************************
//	Some handy ascii values
//*****************************************************************************

enum LH_ASCII_KEY_VALUES
{
	ASC_TAB			= 0x009,	
	ASC_NEWLINE		= 0x00a,
	ASC_SPACE		= 0x020,
};

/**********************************************
 statics
 *********************************************/

//extern CBYTE LHKeyToAscii[];

 /**********************************************
 consts
 *********************************************/

extern const UWORD LH_MOD_SHIFT;
extern const UWORD LH_MOD_CTRL;
extern const UWORD LH_MOD_ALT;

#define	LH_MAX_CURRENT_STRING_LENGTH		30

typedef  void (*LHKBHandler)(UWORD message, LH_KEY key_value,  UWORD modifiers, UWORD repeat_count, void* user_data);
typedef  bool (*LHKBPreHandler)(UWORD msg, LPARAM lParam, WPARAM wParam);

/**********************************************
 classes
 *********************************************/

class	LKeyBuffer
{
public:
	LH_KEY	InKeyValue;
	UBYTE	InKeyModifier;
};

class LHKeyboard
{
private:
	LHKBHandler HandlerFunction;
	LHKBPreHandler PreHandlerFunction;
	void*		UserData;
	UBYTE		KeyDownArray[255];													// Array of any currently pressed keys [indexed by LH_KEY]
	LH_KEY		InKeyValue;															// The value of the last pressed key
	UBYTE		InKeyModifier;														// The value of any currently pressed modifiers (CTRL/ALT/SHIFT)

	CBYTE		StringValue[LH_MAX_CURRENT_STRING_LENGTH+1];						// String is collected here (need to be +1 for term 0)
	LKeyBuffer	KeyBuffer[LH_MAX_CURRENT_STRING_LENGTH];
	ULONG		KeyBufferPos;
	ULONG		KeyBufferLength;
	void		StringCollect(LH_KEY key_value);									// SYS  Fn to collect keystrokes
	ULONG		StringMax;															// Maximum possible string length
	ULONG		StringLength;														// Current string length
	LH_KEY		StringTerminator;													// User has specified this a the char to terminate string input
	BOOL		StringActive;														// Flag as to whether character collection is in progress

public:
				LHKeyboard()					{ InitializeCriticalSection(&KeyboardControl); HandlerFunction = NULL; PreHandlerFunction = NULL;}
	void		Lock()							{ EnterCriticalSection(&KeyboardControl); }
	void		Unlock()						{ LeaveCriticalSection(&KeyboardControl); }

	void		SetHandler(LHKBHandler kb_handler_function, void *user_data=NULL) 
												{HandlerFunction=kb_handler_function; UserData=user_data; }
	void		SetPreHandler(LHKBPreHandler kb_handler_function) 
									{PreHandlerFunction=kb_handler_function;}

	void		Reset()							{memset(KeyDownArray,0,sizeof(KeyDownArray));InKeyModifier=0;}
	void		ProcessKeyboard(UWORD message, LPARAM lParam);						// SYS  Process all keyboard events and maintain user variables
	bool		ProcessKeyboardFilter(UWORD message, LPARAM lParam, WPARAM wParam);						// SYS  Process raw input, return whether failed and should continue with above function
	LH_KEY		InKey()							{return InKeyValue;}				// USER Returns the value of the last key pressed
	void		InKeyClear()					{InKeyValue=KB_NONE;}				// USER Clears the last key pressed variable
	UWORD		InKeyModifiers()				{return InKeyModifier;}				// USER Returns any modifiers
	UBYTE		*KeysDown()						{return KeyDownArray;}				// USER Can test which keys are currently held down

	CBYTE		LHKeyToAscii(LH_KEY key, int shifted=0);
	CBYTE		KeyToAscii(LH_KEY key)			{return(LHKeyToAscii(key));}			// USER Pass an LH_KEY value and get Ascii value back - UNSHIFTED ONLY
	CBYTE		KeyToAsciiWithShift(LH_KEY key)	{return(LHKeyToAscii(key,1));}		// USER Pass an LH_KEY value and get Ascii value back - SHIFTED VERSION
	CBYTE		InKeyToAscii()					{return(LHKeyToAscii(InKeyValue));}		// USER Current Key value as Ascii - UNSHIFTED ONLY
	CBYTE		InKeyToAsciiWithShift()			{return(LHKeyToAscii(InKeyValue,1));}	// USER Current Key value as Ascii - SHIFTED VERSION
	CBYTE		InKeyToActualAscii()			{if(InKeyModifier & LH_MOD_SHIFT) return LHKeyToAscii(InKeyValue,1); else return LHKeyToAscii(InKeyValue);}		// USER Returns the Ascii for the current key pressed - SHIFTED as necessary
	CBYTE		InKeyToActualAscii(LH_KEY inkey, UBYTE mod)			{if(mod & LH_MOD_SHIFT) return LHKeyToAscii(inkey,1); else return LHKeyToAscii(inkey);}		// USER Returns the Ascii for the current key pressed - SHIFTED as necessary

	void		StartString(ULONG max_size=LH_MAX_CURRENT_STRING_LENGTH,LH_KEY terminator=KB_NONE);			
	void		StopString();
	void		RestartString();
	UBYTE*		CurrentString()					{return (UBYTE*)&StringValue;}
	CBYTE		GetStringValue()				{return (StringLength) ? StringValue[--StringLength] : 0;}
	LH_RETURN	GetKeyValue(LH_KEY &inkey, UBYTE &mod);
	void		SetKeyValue();
	BOOL		IsKeyDown(LH_KEY key)			{return (BOOL)KeyDownArray[key];}

	///////////// alex - char buffer

#define BUFSIZE 16 // power of 2 please

	int			charbuf[BUFSIZE];
	int			head,tail;

	int			GetNumCharsInBuf() {int i=head-tail; if (i<0) i+=BUFSIZE;return i;}	
	int			GetNextChar() {if (head==tail) return 0;int o=charbuf[tail];tail=(tail+1)&(BUFSIZE-1);return o;}
	void		ClearBuf() {head=tail=0;}
	void		AddCharToBuf(int chr)
	{
		if (!chr) return;
		if (GetNumCharsInBuf()>=BUFSIZE-1) return;
		charbuf[head]=chr;
		head=(head+1)&(BUFSIZE-1);
	}
};

extern	LH_KEY		PublicInKey;
#endif //__LHKEYBOARD_H__
